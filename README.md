# GraphGenerators
Collection of generators for various different graph classes.

## Graph classes
The list below contains all graph classes supported so far. All graphs are simple, which means they have no loops or multi-edges. The parameter *n* stands for number of vertices, *m* for number of edges, *d* for dimension, *p* for a probability, *g/g1/g2* for a graph, *s* for a seed.

- `emptyGraph(n)`
- `path(n)`, the path *P_n*
- `circle(n)`, the [circle](http://www.graphclasses.org/classes/gc_132.html) *C_n* (not to confuse with a [circle graph](https://en.wikipedia.org/wiki/Circle_graph))
- `prueferTree(n)`, a (unlabelled) tree based on a random [Prüfer sequence](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence)
- `star(n)`, a [star graph](https://en.wikipedia.org/wiki/Star_(graph_theory)) with *n-1* leaves
- `outerplanar(n, s)`, a random [maximal outerplanar graph](https://en.wikipedia.org/wiki/Outerplanar_graph)
- `triangulation(n, steps, s)`, a random maximal [planar graph](https://en.wikipedia.org/wiki/Planar_graph) generated by starting with a random [Apollonian network](https://en.wikipedia.org/wiki/Apollonian_network) and then doing `steps` many random edge flips (recommended to use at least *n^3* many steps)
- `subhamiltonianTriangulation(n, s)`, a random maximal [planar graph](https://en.wikipedia.org/wiki/Planar_graph) that is subhamiltonian, i.e. contains a [Hamiltonian cycle](https://en.wikipedia.org/wiki/Hamiltonian_path), based on the merging two maximal outerplanar graphs
- `kPlanar(n, k, s)`, a [*k*-planar graph](https://en.wikipedia.org/wiki/1-planar_graph) generated from a random point set that is swept from left to right and edges added if they do not introduce more than $k$ crossings
- `kTree(n, k, s)`, a [*k*-tree](https://en.wikipedia.org/wiki/K-tree) (generated as defined recursively, i.e. adding vertex and connecting it to random *k*-clique)
- `hypercube(d)`, the [hypercube](https://en.wikipedia.org/wiki/Hypercube) *Q_d*
- `cubeConnectedCycle(d)`, the [cube-connected cycles graph](https://en.wikipedia.org/wiki/Cube-connected_cycles) based on the hypercube *Q_d*
- `kAryNCube(k, n)`, a *k*-ary *n*-cube which is the product of *n* cycles *C_d*
- `toroidalGraph(n1, n2)`, the product of the cycles *C_n1* and *C_n2* known as a [toroidal graph](https://en.wikipedia.org/wiki/Toroidal_graph)
- `grid(n1, n2)`, a grid of size *n1* times *n2*, i.e. the product of *P_n1* and *P_n2*
- `circulant(n, int[] ... a)`, a [circulant graph](https://en.wikipedia.org/wiki/Circulant_graph) with given steps, e.g. by the array {1, 2, 4}
- `permuation(n, s)` or `permutation(int[] perm)`, [permutation graph](https://en.wikipedia.org/wiki/Permutation_graph) for a random or given permutation
- `bipartite(n)`, a complete balanced) bipartite graph
- `triparitite(n)`, a complate balanced tripartite graph
- `complete(n)`, a [complete graph](https://en.wikipedia.org/wiki/Complete_graph)

There are also some operators that can be applied on the graph
- `shuffle(g)`, randomises the order of the vertices in the data structure and the order of the edges in the adjacency lists
- `density(g, p)`, given a graph *g* and edge probability *p* in *[0,1]* using the [model of Gilbert](https://en.wikipedia.org/wiki/Random_graph) (but referred to as Erdös-Rényi model)
- `graphProduct(g1, g2)`, creates the [product of the two graphs](https://en.wikipedia.org/wiki/Graph_product)


